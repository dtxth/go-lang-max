# Интеграция актуального количества участников чатов

## Проблема
В эндпойнте `/chats/all` поле `participants_count` является статическим и может устареть, так как участники могут покидать/присоединяться к чатам в MAX Messenger.

## Решение: Гибридный подход

### Архитектура
1. **Статическое поле** - остается как fallback и для быстрого ответа
2. **Кэш Redis** - хранит актуальные данные с TTL
3. **Фоновое обновление** - периодически обновляет данные через MAX API
4. **Ленивое обновление** - обновляет при запросе если данные устарели

### Компоненты

#### 1. Кэш-слой (Redis)
```
Key: chat_participants:{chat_id}
Value: {"count": 150, "updated_at": "2025-01-15T10:00:00Z"}
TTL: 1 час
```

#### 2. Фоновый воркер
- Обновляет топ-N активных чатов каждые 15 минут
- Обновляет все чаты раз в сутки (в ночное время)
- Использует батчинг для эффективности

#### 3. Ленивое обновление
- При запросе проверяет возраст данных в кэше
- Если данные старше 1 часа - запрашивает актуальные из MAX API
- Асинхронно обновляет кэш

### Преимущества
- **Быстрый ответ**: основная часть запросов отвечает из кэша
- **Актуальность**: данные обновляются регулярно
- **Отказоустойчивость**: fallback на статическое поле
- **Эффективность**: минимум запросов к MAX API

### Конфигурация
```env
PARTICIPANTS_CACHE_TTL=3600          # 1 час
PARTICIPANTS_UPDATE_INTERVAL=900     # 15 минут для топ чатов
PARTICIPANTS_FULL_UPDATE_HOUR=3      # 3:00 AM для полного обновления
PARTICIPANTS_BATCH_SIZE=50           # размер батча для MAX API
```

## Реализация

### Этап 1: Кэш-слой
- Добавить Redis клиент в chat-service
- Создать ParticipantsCache интерфейс
- Реализовать кэширование в репозитории

### Этап 2: Интеграция с MAX API
- Добавить MAX API клиент в chat-service
- Создать ParticipantsUpdater сервис
- Реализовать батчевое обновление

### Этап 3: Фоновые задачи
- Создать воркер для периодического обновления
- Добавить метрики и мониторинг
- Настроить graceful shutdown

### Этап 4: API изменения
- Модифицировать GetAllChatsWithSortingAndSearch
- Добавить поле `participants_count_updated_at`
- Добавить флаг `use_cached_participants`

## Альтернативные стратегии

### 2. Реалтайм подход
- Запрос к MAX API при каждом вызове `/chats/all`
- **Плюсы**: всегда актуальные данные
- **Минусы**: медленно, нагрузка на MAX API, риск rate limiting

### 3. Событийный подход
- Подписка на события MAX Messenger (если доступно)
- **Плюсы**: мгновенные обновления
- **Минусы**: сложность, зависимость от внешних событий

### 4. Пользовательский выбор
- Параметр `?fresh_participants=true` для принудительного обновления
- **Плюсы**: гибкость для пользователя
- **Минусы**: сложность UX, непредсказуемая нагрузка

## Метрики и мониторинг

### Ключевые метрики
- `participants_cache_hit_rate` - процент попаданий в кэш
- `participants_update_duration` - время обновления данных
- `participants_max_api_errors` - ошибки MAX API
- `participants_stale_data_count` - количество устаревших данных

### Алерты
- Низкий hit rate кэша (< 80%)
- Высокая частота ошибок MAX API (> 5%)
- Долгое время обновления (> 30 сек)

## Производительность

### Ожидаемые показатели
- **Время ответа**: < 100ms (из кэша), < 2s (с обновлением)
- **Нагрузка на MAX API**: ~100 запросов/час (вместо потенциальных тысяч)
- **Актуальность данных**: 95% данных свежее 1 часа

### Масштабирование
- Горизонтальное масштабирование воркеров
- Шардинг кэша по chat_id
- Приоритизация популярных чатов